#!/usr/bin/env bash
set -e

red=$(tput setaf 1)
green=$(tput setaf 2)
yellow=$(tput setaf 3)
blue=$(tput setaf 4)
bold=$(tput bold)
reset=$(tput sgr0)

dump=false
kdebug=false
logs=false
args=()
while [[ "$#" -gt '0' ]]; do
    arg="$1"
    case "$arg" in
        --dump|-d ) dump=true    ; shift   ;;
        --kdebug  ) kdebug=true  ; shift   ;;
        --logs    ) logs=true    ; shift   ;;
        *         ) args+=("$1") ; shift   ;;
    esac
done
set "${args[@]}"

export KLAB_OUT=${KLAB_OUT:-out}
export K_OPTS="${K_OPTS:--Xmx16G -Xss512m}"

if [ -z "$KLAB_EVMS_PATH" ]; then
    echo "KLAB_EVMS_PATH must be set and point to evm-semantics!"
    exit 1
fi
echo "Using evm-semantics from $KLAB_EVMS_PATH"

if [ -z "$1" ]; then
  spec_hash=${KLAB_HEAD:-$(cat "$KLAB_OUT/HEAD")}
  spec_name=$(<"$KLAB_OUT/meta/data/$spec_hash" jq '.name' -r)
  if [ -z "$spec_hash" ]; then
    echo "ERROR: $1 no spec or active HEAD found"
    exit 1;
  fi
elif [ -f "$KLAB_OUT/meta/name/$1" ]; then
  spec_hash=$(cat "$KLAB_OUT/meta/name/$1")
  spec_name=$1
elif [ -f "$KLAB_OUT/meta/data/$1" ]; then
  spec_hash="$1"
  spec_name=$(<"$KLAB_OUT/meta/data/$spec_hash" jq '.name' -r)
elif [[ $1 =~ .k$ ]]; then
  target_spec=$1
  spec_hash=$(basename -s .k "$1")
  spec_name=$(basename -s .k "$1")
else
  echo "ERROR: $1 is unknown"
  exit 1;
fi;

if $logs; then
  mkdir -p "$KLAB_OUT/log/"
  STDOUT="$KLAB_OUT/log/$spec_hash.log"
  STDERR="$KLAB_OUT/log/$spec_hash.err.log"
else
  STDOUT=/dev/stdout
  STDERR=/dev/stderr
fi

target_spec=${target_spec:-"$KLAB_OUT/specs/${spec_hash}.k"}

K_FLAGS=()
if $dump; then
  z3=",RULEATTEMPT,SRULEATTEMPT,IMPLICATION,Z3QUERY,Z3RESULT"
  K_FLAGS+=(--state-log --state-log-path "$KLAB_OUT/data" --state-log-id "$spec_hash" --state-log-events "OPEN,REACHINIT,REACHTARGET,REACHPROVED,RULE,SRULE,NODE,CLOSE")
  dump_notice="(with ${yellow}state logging${reset})"
fi

if $kdebug; then
  K_FLAGS+=(--debug --debug-z3)
fi

info="$(basename "$target_spec") [$spec_name] $dump_notice"
mkdir -p "$KLAB_OUT/started" && echo "$result" > "$KLAB_OUT/started/$spec_hash"
echo "${blue}Proof ${bold}STARTING${reset}: $info"
set +e
trap 'echo "Trapped SIGTERM in klab-prove" && kill $kprove_child' TERM
trap 'echo "Trapped SIGINT in klab-prove"  && kill $kprove_child' INT
"$KLAB_EVMS_PATH/deps/k/k-distribution/target/release/k/bin/kprove" \
  "${K_FLAGS[@]}" \
  --directory "$KLAB_EVMS_PATH/.build/defn/java/" \
  --def-module VERIFICATION \
  --output-omit "<jumpDests> <program> <code> <previousGas> <touchedAccounts> <interimStates> <callStack> <callData> <block> <txOrder> <txPending> <messages> #mkCall________EVM #callWithCode_________EVM #create_____EVM #mkCreate_____EVM #newAddrCreate2 #finishCodeDeposit___EVM" \
  --output-flatten "_Map_ #And" \
  --z3-impl-timeout 300 --no-exc-wrap \
  --cache-func-optimized --format-failures \
  --no-alpha-renaming \
  --no-sort-collections \
  --output json \
  --boundary-cells k,pc \
  --z3-tactic "(or-else (using-params smt :random-seed 3) (using-params smt :random-seed 2) (using-params smt :random-seed 1))" \
  "$@" \
  "$target_spec" >"$STDOUT" 2>"$STDERR" & kprove_child=$!
wait "$kprove_child"
result=$?
unset kprove_child
set -e

if [ $result -eq 0 ]; then
  mkdir -p "$KLAB_OUT/accept" && echo "$result" > "$KLAB_OUT/accept/$spec_hash"
  echo "${green}Proof ${bold}ACCEPT${reset}: $info"
elif [ $result -gt 127 ]; then
  # results > 127 are 128 + signal number
  mkdir -p "$KLAB_OUT/aborted" && echo "$(($result%128))" > "$KLAB_OUT/aborted/$spec_hash"
  echo "Proof ${bold}ABORT${reset} $result SIG$(kill -l $result): $info"
else
  mkdir -p "$KLAB_OUT/reject" && echo "$result" > "$KLAB_OUT/reject/$spec_hash"
  echo "${red}Proof $result ${bold}REJECT${reset}: $info"
fi
exit $result
